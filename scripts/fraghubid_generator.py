import concurrent.futures
from tqdm import tqdm
from convertors.loaders import *
import hashlib
import ijson
import json
import sys
import os
import re

global inchikey_update_pattern
inchikey_update_pattern = re.compile(r"([A-Z]{14}-[A-Z]{10}-[NO])", flags=re.IGNORECASE)

global peak_list_split_update_pattern
peak_list_split_update_pattern = re.compile(r"(-?\d+\.?\d*(?:[Ee][+-]?\d+)?)(?:\s+|:)(-?\d+[.,]?\d*(?:[Ee][+-]?\d+)?)")

def get_peak_list_key(spectrum):
    """
    :param spectrum: A dictionary representing a spectrum object. It should contain keys related to peaks and their information.
    :return: The key in the spectrum dictionary that corresponds to the peak list. If no key is found, returns None.
    """
    peak_list_keys = ["spectrum", "peaks_json", "peaks"]
    for key in peak_list_keys:
        if key in spectrum:
            return key

    return None

def hash_spectrum_data(spectrum_data):
    """
    Calculate the SHA256 hash of spectrum data.

    :param spectrum_data: The spectrum data to hash.
    :type spectrum_data: str
    :return: The SHA256 hash of spectrum data.
    :rtype: str
    """
    spectrum_string = str(spectrum_data)

    inchikey = re.search(inchikey_update_pattern, spectrum_string)
    key = get_peak_list_key(spectrum_data)
    if key:
        peak_list = str(spectrum_data[key])

        if inchikey:
            inchikey = inchikey.group(1)

        if inchikey and peak_list:
            spectrum_string = inchikey+"\n"+peak_list

        # Créer un objet sha256
        sha256 = hashlib.sha256()

        # Fournir les données de spectre à sha256
        sha256.update(spectrum_string.encode('utf-8'))

        # Retourner le hash sha256 en hex
        return sha256.hexdigest()

    return None

def genrate_fraghubid(spectrum):
    """
    Generate FragHubID for a given spectrum.

    :param spectrum: The spectrum data.
    :return: The spectrum data with Fragment Hub ID.
    """
    fraghubid = str(hash_spectrum_data(spectrum))
    if not fraghubid:
        return None
    new_spectrum = {"FRAGHUBID": fraghubid}
    new_spectrum.update(spectrum)

    return new_spectrum


def generate_fraghubid_processing(spectrum_list, files):
    """
    Perform parallel processing of the given spectrum list and generate fraghubid for each spectrum.

    :param spectrum_list: A list of spectra.
    :return: A list of fraghubids generated for each spectrum.
    """
    filename = os.path.basename(files)
    chunk_size = 5000  # Set the size of chunks
    final = []

    progress_bar = tqdm(total=len(spectrum_list), unit=" spectrums", colour="green", desc="{:>70}".format(f"generating FragHubID on [{filename}]"))

    # Dividing the spectrum list into chunks
    for i in range(0, len(spectrum_list), chunk_size):
        with concurrent.futures.ThreadPoolExecutor() as executor:
            chunk = spectrum_list[i:i + chunk_size]  # create a chunk
            results = list(executor.map(genrate_fraghubid, chunk))
            progress_bar.update(len(chunk))  # update the progress bar by the size of the chunk processed

        final.extend([res for res in results if res is not None])  # Extend the final results list with results that are not None

    progress_bar.close()

    return final  # return the final results

def process_converted_after(spectrum_list, mode):
    """
    Process converted spectrum list after conversion.

    :param spectrum_list: List of converted spectra.
    :param mode: Conversion mode. Can be "MSP", "XML", "CSV", or "JSON".
    :return: Processed spectrum list.
    """
    if mode == "MSP":
        file_path = os.path.abspath("../INPUT/CONVERTED/MSP_converted.json")
        filename = os.path.basename(file_path)
    elif mode == "XML":
        file_path = os.path.abspath("../INPUT/CONVERTED/XML_converted.json")
        filename = os.path.basename(file_path)
    elif mode == "CSV":
        file_path = os.path.abspath("../INPUT/CONVERTED/CSV_converted.json")
        filename = os.path.basename(file_path)
    elif mode == "JSON":
        file_path = os.path.abspath("../INPUT/CONVERTED/JSON_converted.json")
        filename = os.path.basename(file_path)
    elif mode == "MGF":
        file_path = os.path.abspath("../INPUT/CONVERTED/MGF_converted.json")
        filename = os.path.basename(file_path)

    spectrum_list = generate_fraghubid_processing(spectrum_list, filename)

    return spectrum_list

def generate_fraghub_id(FINAL_MSP, FINAL_XML, FINAL_CSV, FINAL_JSON, FINAL_MGF):
    """
    :param msp_directory_path: The path to the MSP directory.
    :return: None

    This method generates a FragHub ID for each MSP file in the given directory. It loops through all the files in the directory and checks if they have a .msp extension. For each .msp file
    *, it checks if a FragHub ID has already been generated by calling the `check_fraghubid_already_done` method. If a FragHub ID hasn't been generated, it loads the spectrum list from the
    * MSP file using the `load_spectrum_list` method. Then, it processes the spectrum list to generate the FragHub ID using the `generate_fraghubid_processing` method.

    Finally, it opens the MSP file in write mode and writes the modified spectrum list with the generated FragHub ID into the file.
    """
    if FINAL_MSP:
        FINAL_MSP = process_converted_after(FINAL_MSP, "MSP")
    if FINAL_XML:
        FINAL_XML = process_converted_after(FINAL_XML, "XML")
    if FINAL_CSV:
        FINAL_CSV = process_converted_after(FINAL_CSV, "CSV")
    if FINAL_JSON:
        FINAL_JSON = process_converted_after(FINAL_JSON, "JSON")
    if FINAL_MGF:
        FINAL_MGF = process_converted_after(FINAL_MGF, "MGF")

    return FINAL_MSP, FINAL_XML, FINAL_CSV, FINAL_JSON, FINAL_MGF
