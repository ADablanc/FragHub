import concurrent.futures
import uuid

from tqdm import tqdm
import hashlib
import ijson
import json
import os
import re

global inchikey_update_pattern
inchikey_update_pattern = re.compile(r"([A-Z]{14}-[A-Z]{10}-[NO])", flags=re.IGNORECASE)

global peak_list_update_pattern
peak_list_update_pattern = re.compile(r"\"peaks\":([\S\s]*?)\}", flags=re.IGNORECASE)

global peak_list_split_update_pattern
peak_list_split_update_pattern = re.compile(r"(-?\d+\.?\d*(?:[Ee][+-]?\d+)?)(?:\s+|:)(-?\d+[.,]?\d*(?:[Ee][+-]?\d+)?)")


def load_spectrum_list_json(json_file_path):
    """
    Load spectra from a JSON file and return a list of spectra.

    :param json_file_path: Path to the JSON file.
    :return: List of spectra.
    """
    spectrum_list = []

    # First, calculate total bytes for tqdm
    total_bytes = os.path.getsize(json_file_path)

    with open(json_file_path, 'r', encoding="UTF-8") as file:
        # ijson.items(file, 'item') returns a generator yielding items in a JSON file
        spectra = ijson.items(file, 'item')
        # Create tqdm progress bar
        progress = tqdm(total=total_bytes, unit="B", unit_scale=True, colour="green", desc="{:>80}".format("Loading file"))

        for spectrum in spectra:
            spectrum_list.append(spectrum)
            progress.update(len(str(spectrum)))
        progress.close()

    return spectrum_list

def hash_spectrum_data(spectrum_data):
    """
    Calculate the SHA256 hash of spectrum data.

    :param spectrum_data: The spectrum data to hash.
    :type spectrum_data: str
    :return: The SHA256 hash of spectrum data.
    :rtype: str
    """
    spectrum_string = str(spectrum_data)

    inchikey = re.search(inchikey_update_pattern, spectrum_string)
    peak_list = re.search(peak_list_update_pattern, spectrum_string)

    if inchikey:
        inchikey = inchikey.group(1)

    if inchikey and peak_list:
        peak_list = peak_list.group(1)
        spectrum_string = inchikey+"\n"+peak_list

    else:
        spectrum_string = str(spectrum_data)

    # Créer un objet sha256
    sha256 = hashlib.sha256()

    # Fournir les données de spectre à sha256
    sha256.update(spectrum_string.encode('utf-8'))

    # Retourner le hash sha256 en hex
    return sha256.hexdigest()

def genrate_fraghubid(spectrum):
    """
    Generate FragHubID for a given spectrum.

    :param spectrum: The spectrum data.
    :return: The spectrum data with Fragment Hub ID.
    """
    fraghubid = str(hash_spectrum_data(spectrum))
    new_spectrum = {"FRAGHUBID": fraghubid}
    new_spectrum.update(spectrum)

    return new_spectrum

def genrate_fraghubid_processing(spectrum_list, files):
    """
    Perform parallel processing of the given spectrum list and generate fraghubid for each spectrum.

    :param spectrum_list: A list of spectra.
    :return: A list of fraghubids generated for each spectrum.
    """
    filename = os.path.basename(files)
    with concurrent.futures.ThreadPoolExecutor() as executor:
        results = list(tqdm(executor.map(genrate_fraghubid, spectrum_list), total=len(spectrum_list), unit=" spectrums", colour="green", desc="{:>80}".format(f"generating FragHubID on [{filename}]")))

    final = [res for res in results if res is not None]

    return final # returns the list of different worker executions.


def check_fraghubid_already_done(json_file_path):
    """
    Check if a FragHubID is already done in a given file.

    :param json_file_path: The file path of the JSON file to check.
    :type json_file_path: str
    :return: True if a FRAGHUBID is found, False otherwise.
    :rtype: bool
    """
    with open(json_file_path, 'r') as file:
        # ijson items returns a generator yielding items in a json file
        objects = ijson.items(file, '')

        first_dict = next(objects)

        # check if 'FRAGHUBID' is in the first dictionary
        if 'FRAGHUBID' in first_dict:
            return True

    # 'FRAGHUBID' was not found or file was empty
    return False

def generate_fraghub_id(json_directory_path):
    """
    :param msp_directory_path: The path to the MSP directory.
    :return: None

    This method generates a FragHub ID for each MSP file in the given directory. It loops through all the files in the directory and checks if they have a .msp extension. For each .msp file
    *, it checks if a FragHub ID has already been generated by calling the `check_fraghubid_already_done` method. If a FragHub ID hasn't been generated, it loads the spectrum list from the
    * MSP file using the `load_spectrum_list` method. Then, it processes the spectrum list to generate the FragHub ID using the `generate_fraghubid_processing` method.

    Finally, it opens the MSP file in write mode and writes the modified spectrum list with the generated FragHub ID into the file.
    """
    json_path_list = []

    for root, dirs, files in os.walk(json_directory_path):
        for file in files:
            if file.endswith(".json"):
                json_path_list.append(os.path.join(root, file))

    for files in json_path_list:
        if files.endswith(".json"):
            if not check_fraghubid_already_done(str(files)):
                spectrum_list = load_spectrum_list_json(files)
                spectrum_list = genrate_fraghubid_processing(spectrum_list, files)

                if spectrum_list:
                    with open(files, "w", encoding="UTF-8") as buffer:
                        json.dump(spectrum_list, buffer, ensure_ascii=False, indent=1)